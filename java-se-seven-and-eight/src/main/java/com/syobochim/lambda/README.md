# 関数型インターフェース

既存のインターフェースの中にも関数型インターフェースとして扱えるインターフェースの一例。

* java.lang.Runnable
* java.util.concurrent.Callable
* java.util.Comparator<T>


## 基本となる関数型インターフェース

インターフェースはたくさんあるが、基本となるインターフェースは以下の通り。

|インターフェース名|メソッド名|説明|
|:-------------:|:--------:|:------:|
|Function<T, R>|R apply(T t)|引数あり、返り値あり|
|Consumer<T>|void accept(T t)|引数あり、返り値なし|
|Predicate<T>|boolean test(T t)|引数あり、返り値boolean|
|Supplier<T>|T get()|引数なし、返り値あり|

また、int / long / double の3つの型に対応した関数型インターフェースもある。

* IntFunction
* DoubleFunction

Functionインターフェース系のサブインターフェースとして以下が提供されている。

|インターフェース名|スーパーインターフェース名|メソッド名|説明|
|:--------------:|:--------------------:|:-----:|:----|
|UnaryOperator<T>|Function<T, T>|T apply(T t)|引数と返り値が同じ|
|BinaryOperator<T>|BiFunction<T, T, T>|T apply(T t1, T t2)|引数と返り値が同じ。引数は二つ|

引数を二つにしたインターフェースはインターフェース名の先頭にBiがつく。

## 関数型インターフェースの作成

自分で関数型インターフェースを作成することもできる。実装するメソッドが１つのインターフェースを作成すればいい。
以下のようにアノテーションをつけることで、インターフェースが関数型インターフェースかチェックすることができる。アノテーションは必須ではない。

```java
@FunctionalInterface
public interface TriFunction<S, T, U, R> {
    R apply(S s, T t, U u);
}
```

## 実質的final

ラムダ式は変数のスコープも匿名クラスと同じになる。
ラムダしきを含むクラスのフィールドアクセスが可能。
ローカル変数のアクセスはfinalな変数の参照に限られる。

## thisの違い

ラムダ式と匿名クラスでは、thisを使った時に示す対象が異なる。匿名クラスは自分自身。ラムダ式はラムダ式を定義しているクラス自体。

# デフォルトメソッド

定義方法は↓

```java
interface インターフェース名{
    default 返り値の型 メソッド名(引数) {
        // 処理
    }
}
```

デフォルトメソッドはアブストラクトで実装されているメソッドと同様な扱いになる。ただし、状態は保持出来ない。

## 多重継承はできない

Javaでは多重継承はできないがインターフェースに実装を定義できると、多重継承の問題が発生してしまう。
多重継承を避けるため、インターフェースで同じシグネチャのメソッドが複数の実装をもつ場合、それを実装するクラスで必ずメソッドをオーバーライドしなくてはならない。

### class always wins

実装クラスがある場合は実装クラスが優先される。

デフォルトメソッドの導入によって、実装が複数になる可能性がある。そのため、superメソッドだけはコールするメソッドを一意に決めることができなくなってしまった。
そこで、クラス名もしくはインターフェース名をsuperの前に追記して、メソッドを指定することができるようになった。

# インターフェースのstaticメソッド

インターフェースにstaticメソッドを定義することもできる。

```java
static <T> Fuction<T, T> identity(){
    return t -> t;
}
```

